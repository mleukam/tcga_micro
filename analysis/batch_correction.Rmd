---
title: "batch_correction"
author: "Michael Leukam"
date: "2021-02-03"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Summary

```
Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Missing counts converted to zeros. 

Three types of data were batch corrected and saved for downstream use. The original (not batch corrected) forms were also saved for downstream use. 

The three types of data are:

* Counts per million total original (human and microbial) reads (extracted from Agamemnon logs) 

* Counts per million microbial counts (converted from raw count matrix using EdgeR cpm() function)

* Raw counts estimates from Agamemnon

For each data type: 
TMM normalization factors used for voom normalization with tumor type set as experimental design. Normalized results then batch corrected using limma::removeBatchEffect using tumor type as experimental design and combination of sequencing center and plate (extracted from TCGA barcode) as batch effect. Counts converted back to log space and very low values (noise introduced from log conversion) rounded back to 0.
```

From the manual for limma::removeBatchEffect

```
This function is useful for removing batch effects, associated with hybridization time or other technical variables, prior to clustering or unsupervised analysis such as PCA, MDS or heatmaps. It is not intended to use with linear modelling. For linear modelling, it is better to include the batch factors in the linear model.

The design matrix is used to describe comparisons between the samples, for example treatment effects, which should not be removed.

The function (in effect) fits a linear model to the data, including both batches and regular treatments, then removes the component due to the batch effects.

The data object x can be of any class for which lmFit works. If x contains weights, then these will be used in estimating the batch effects.
```

## Setup

Clear the workspace and set seed
```{r}
rm(list=ls())
set.seed(818)
```

Load packages
```{r message=FALSE, warning=FALSE}
# data cleaning
library(tidyverse)
library(Biobase)
library(Matrix.utils)
library(limma)
library(ggpubr)
library(edgeR)
library(sva)
```

## Data Prep
```{r}
# read in counts from tcga_data_prep
tcga_counts <- readRDS("data/mode2_tcga_counts_list_clean.rds")
str(tcga_counts, max.level = 2)
str(tcga_counts$cpm_counts, max.level = 2)
str(tcga_counts$counts$genus, max.level = 3)
tcga_counts$cpm_counts$cpm_clindat[[1]]
```

Prepare raw counts
```{r}
## Pull out RAW counts------------------------------------
counts_list <- tcga_counts$counts
str(counts_list, max.level = 2)

# get linked clinical data to set up limma model
# convert to dataframe with subjects in rows
clindat <- tcga_counts$clindat %>%
  # collapse list to single tbl
  enframe() %>%
  unnest(value) %>%
  rename(tcga_proj = name) %>%
  # remove duplicates (very few)
  distinct(tcga_barcode, .keep_all = TRUE) %>%
  # create variable for plate and center == batch
  separate(tcga_full_barcode, 
           into = c(NA, NA, NA, NA, NA, "plate", "center"), 
           sep = "-", 
           remove = FALSE) %>%
  unite("batch", 
        c("plate", "center"), 
        sep = "", 
        remove = FALSE) %>%
  # convert to df with rownames
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

# review
dim(clindat)
colnames(clindat)
clindat[1:5, 1:5]

# repair taxonomy
taxonomy_nomissing <- readRDS("data/tcga_proj_taxonomy_nomissing.rds")

genus_counts_repaired <- counts_list$taxid %>%
   # collapse list to single tbl
  bind_rows() %>%
  # remove duplicates (very few, about 30)
  distinct(tcga_barcode, .keep_all = TRUE) %>%
  # rotate table
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode") %>%
  as.matrix() %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "Scientific_Name") %>%
  as_tibble() %>%
  # join in taxonomy
  left_join(taxonomy_nomissing) %>%
  select(Genus, Species, Scientific_Name, everything()) %>%
  arrange(Genus) %>%
  # fix messed up name
  mutate(Genus = ifelse(Genus == "---_Class", "Tissierella_Class", Genus)) %>%
  # clean up
  select(-Species, -Scientific_Name, - Superkingdom, -Phylum, -Class, -Order, -Family, -TaxID)
# get rownames (has duplicates)
genus_counts_rnames <- genus_counts_repaired %>%
  pull(Genus)
# get data for matrix
genus_counts_matrix <- genus_counts_repaired %>%
  dplyr::select(-Genus) %>%
  as.matrix()
# add back rownames in matrix form
rownames(genus_counts_matrix) <- genus_counts_rnames
genus_counts_matrix[1:5, 1:5]
# collapse by averaging
genus_counts <- limma::avereps(genus_counts_matrix)
 # cases are in columns and features are in rows

# check results
dim(genus_counts)
genus_counts[1:5, 1:5]

# repair clinical data to match genus cpm
clindat_genus_tbl <- clindat %>%
  rownames_to_column(var = "tcga_barcode") %>%
  as_tibble()
clindat_genus_counts <- enframe(colnames(genus_counts)) %>%
  dplyr::select(tcga_barcode = value) %>%
  left_join(clindat_genus_tbl) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

# check results
dim(clindat_genus_counts)
clindat_genus_counts[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_counts), rownames(clindat_genus_counts))
length(rownames(clindat_genus_counts))
length(colnames(genus_counts))
```

Initial Data Cleaning
```{r}
# should pass non-log counts to voom
# voom includes a log2 transformation
# convert missing counts to 0
dim(genus_counts)
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
genus_counts[is.na(genus_counts)] <- 0
summary(as.factor(is.na(genus_counts)))

# check other non-numeric values
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))

# remove cases with any infinite values
genus_counts[!is.finite(genus_counts)] <- NA
genus_counts <- genus_counts[, colSums(is.na(genus_counts)) == 0]

# check again
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))
dim(genus_counts)

# remove cases with library size 0
dim(genus_counts)
genus_counts_filt <- genus_counts[, colSums(genus_counts != 0) > 0]
dim(genus_counts_filt)
```

## Genus Limma batch correction

Note that voom adds 0.5 to counts and then log-transforms (log2).

#### Genus CPM
```{r}
## CPM using total reads (microbial and human)--------------------

# make lookup table
cpm_lookup <- tcga_counts$cpm_counts$cpm_clindat %>%
  bind_rows() %>%
  select(tcga_barcode, totreads) %>%
  print()

clindat_genus_tbl <- tcga_counts$clindat %>%
  enframe() %>%
  unnest(value) %>%
  rename(tcga_proj = name) %>%
  # keep only the first record for duplicated barcodes
  distinct(tcga_barcode, .keep_all = TRUE) %>%
  # create the batch variable
  separate(tcga_full_barcode, 
           into = c(NA, NA, NA, NA, "part1", "part2", NA), 
           sep = "-",
           remove = FALSE) %>%
  unite(col = "batch", c("part1", "part2"), sep = "_", remove = TRUE) %>%
  print()

# convert to CPM
genus_cpm <- t(genus_counts) %>%
  as.data.frame() %>%
  rownames_to_column(var = "tcga_barcode") %>%
  as_tibble() %>%
  left_join(cpm_lookup) %>%
  select(tcga_barcode, totreads, everything()) %>%
  # remove cases with 0 total reads
  filter(totreads > 0) %>%
  # get per million scaling factor
  mutate(factor = totreads / 10^6) %>%
  select(tcga_barcode, factor, everything()) %>%
  select(-totreads) %>%
  # divide by readcounts
  mutate(across(-c(factor, tcga_barcode), ~ . / factor)) %>%
  select(-factor) %>%
  # remove small number of duplicate samples
  distinct(tcga_barcode, .keep_all = TRUE) %>%
  # convert to matrix and rotate table
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode") %>%
  as.matrix() %>%
  t()

# review results
genus_cpm[1:5, 1:5]
dim(genus_cpm)

# density plot
genus_tidy <- genus_cpm %>%
  as.data.frame() %>%
  rownames_to_column(var = "genus") %>%
  as_tibble() %>%
  pivot_longer(`TCGA-BH-A5IZ`:`TCGA-FY-A3BL`, 
               names_to = "tcga_barcode", 
               values_to = "cpm", 
               values_drop_na = FALSE) %>%
  print()
ggplot(genus_tidy, aes(x = cpm)) +
  geom_density() +
  xlim(-0.1, +0.1)

# recheck for wacky data
# convert missing counts to 0
dim(genus_cpm)
summary(as.factor(is.na(genus_cpm)))
summary(as.factor(is.nan(genus_cpm)))
genus_counts[is.na(genus_cpm)] <- 0
summary(as.factor(is.na(genus_cpm)))
# check other non-numeric values
summary(as.factor(is.nan(genus_cpm)))
summary(as.factor(is.finite(genus_cpm)))
# remove cases with any infinite values
genus_counts[!is.finite(genus_cpm)] <- NA
genus_counts <- genus_cpm[, colSums(is.na(genus_cpm)) == 0]
# final review
summary(as.factor(is.na(genus_cpm)))
summary(as.factor(is.nan(genus_cpm)))
summary(as.factor(is.finite(genus_cpm)))
dim(genus_cpm)

# remove cases with library size 0
dim(genus_cpm)
genus_cpm_filt <- genus_cpm[, colSums(genus_cpm != 0) > 0]
dim(genus_cpm_filt)

# repair clinical data to match genus cpm after cases were dropped

clindat_genus_cpm_filt <- enframe(colnames(genus_cpm_filt)) %>%
  dplyr::select(tcga_barcode = value) %>%
  left_join(clindat_genus_tbl) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

dim(clindat_genus_cpm_filt)
clindat_genus_cpm_filt[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_cpm_filt), rownames(clindat_genus_cpm_filt))
length(rownames(clindat_genus_cpm_filt))
length(colnames(genus_cpm_filt))

#--------------------------------
## VOOM NORMALIZATION AND BATCH CORRECTION WITH LIMMA ##
dim(genus_cpm_filt)

dim(clindat_genus_cpm_filt)
clindat_genus_cpm_filt[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_cpm_filt), rownames(clindat_genus_cpm_filt))
length(rownames(clindat_genus_cpm_filt))
length(colnames(genus_cpm_filt))

# create DGEList
dge <- DGEList(counts = genus_cpm_filt)

# apply TMM normalization to DGE
dge <- calcNormFactors(dge)

# set up design matrix
# design matrix should include real differences to be preserved
# Rob Knight paper used tumor type as real difference
# I will do the same
rnames <- rownames(clindat_genus_cpm_filt)
TCGA_ <- clindat_genus_cpm_filt$tcga_proj %>% as.factor()
summary(TCGA_)
design <- model.matrix(~ 0 + TCGA_)
rownames(design) <- rnames
head(design)

# include sequencing center / plate as a batch variable to the model
batch <- as.factor(clindat_genus_cpm_filt$batch)
summary(batch)

# remove batch effects
v <- voom(dge, design, plot = TRUE)
genus_cpm_corrected <- removeBatchEffect(v, batch = batch, design = design)

# convert log values back to count values
genus_cpm_recounts <- exp(genus_cpm_corrected) - 0.5

# check for negative results
genus_cpm_recounts[genus_cpm_recounts < 0] %>% length()
# what is lowest value?
genus_cpm_recounts %>% min()
# round values close to 0 down to 0
summary(as.numeric(genus_cpm_recounts))
summary(cpm_lookup$totreads)
# median number of identified reads is 5.5 million
# 0.18 CPM would equal 1 read in 5.5 million.
# values below this are likely noise
# this will affect 6749/1764360 values or 0.4%
length(genus_cpm_recounts)
length(genus_cpm_recounts[genus_cpm_recounts < 0.18])
genus_cpm_recounts[genus_cpm_recounts < 0.18] <- 0
genus_cpm_recounts[1:5, 1:5]
genus_counts[1:5, 1:5]
# check for missing results
summary(as.factor(is.finite(genus_cpm_recounts)))

genus_cpm_recounts[1:5, 1:5]

# fix the clinical data to match
clindat_genus_cpm_recount <- enframe(colnames(genus_cpm_recounts)) %>%
  dplyr::select(tcga_barcode = value) %>%
  left_join(clindat_genus_tbl) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

dim(clindat_genus_cpm_recount)
clindat_genus_cpm_recount[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_cpm_recounts), rownames(clindat_genus_cpm_recount))
length(rownames(clindat_genus_cpm_recount))
length(colnames(genus_cpm_recounts))

# save corrected results as ExpressionSet-------------------------
# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_cpm_recount),
  row.names = colnames(clindat_genus_cpm_recount))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_cpm_recount, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format
genus_cpm_mat <- genus_cpm_recounts %>% as.matrix()

genus_cpm_mat[1:5, 1:5]

# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Converted to counts per million total original (human and microbial) reads (extracted from Agamemnon logs). Missing counts converted to zeros. TMM normalization factors used for voom normalization with tumor type set as experimental design. Batch corrected using limma::removeBatchEffect using tumor type as experimental design and combination of sequencing center and plate (extracted from TCGA barcode) as batch effect. Converted back to count space from log2 values. CPM values below 0.18 (1 in original median 5.5 million reads) converted to 0, about 0.3% of reads")

# assemble expressionset
genus_cpm_es <- ExpressionSet(
  assayData = genus_cpm_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_cpm_es

# save
saveRDS(genus_cpm_es, "output/corrected_genus_cpm_expressionset.rds")

# save uncorrected values as ExpressionSet---------------------

# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_cpm_recount),
  row.names = colnames(clindat_genus_cpm_recount))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_cpm_recount, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format
genus_unc_cpm_mat <- v$E %>%
  exp() - 0.5

  # check for negative results
genus_unc_cpm_mat[genus_unc_cpm_mat < 0] %>% length()
# what is lowest value?
genus_unc_cpm_mat %>% min()

# round values close to 0 down to 0
summary(as.numeric(genus_unc_cpm_mat))
summary(cpm_lookup$totreads)
# median number of identified reads is 5.5 million
# 0.18 CPM would equal 1 read in 5.5 million.
# values below this are likely noise
# this will affect 537/1764360 values or 0.03%
length(genus_unc_cpm_mat)
length(genus_unc_cpm_mat[genus_unc_cpm_mat < 0.18])
genus_cpm_recounts[genus_cpm_recounts < 0.18] <- 0
# check for missing results
summary(as.factor(is.finite(genus_cpm_recounts)))

genus_unc_cpm_mat[1:5, 1:5]

# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Converted to counts per million total original (human and microbial) reads (extracted from Agamemnon logs) Missing counts converted to zeros. TMM normalization factors used for voom normalization with tumor type set as experimental design. Converted back to count space from log2 values. CPM values below 0.18 (1 in original median 5.5 million reads) converted to 0, which affects 537 reads.")

# assemble expressionset
genus_cpm_unc_es <- ExpressionSet(
  assayData = genus_unc_cpm_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_cpm_unc_es

# save
saveRDS(genus_cpm_unc_es, "output/uncorrected_genus_cpm_expressionset.rds")
```

#### Genus raw counts
```{r}
#--------------------------------
## FINAL DATA CLEANING ##
# should pass non-log counts to voom and COMBAT-seq
# voom includes a log2 transformation

# convert missing counts to 0
dim(genus_counts)
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
genus_counts[is.na(genus_counts)] <- 0
summary(as.factor(is.na(genus_counts)))

# check other non-numeric values
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))

# remove cases with any infinites
genus_counts[!is.finite(genus_counts)] <- NA
genus_counts <- genus_counts[, colSums(is.na(genus_counts)) == 0]

# check again
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))
dim(genus_counts)

# remove cases with library size 0
dim(genus_counts)
genus_counts_filt <- genus_counts[, colSums(genus_counts != 0) > 0]
dim(genus_counts_filt)

# repair clinical data to match genus counts after cases were dropped
clindat_genus_tbl <- clindat %>%
  rownames_to_column(var = "tcga_barcode") %>%
  as_tibble()

clindat_genus_counts_filt <- enframe(colnames(genus_counts_filt)) %>%
  dplyr::select(tcga_barcode = value) %>%
  left_join(clindat_genus_tbl) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

dim(clindat_genus_counts_filt)
clindat_genus_counts_filt[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_counts_filt), rownames(clindat_genus_counts_filt))
length(rownames(clindat_genus_counts_filt))
length(colnames(genus_counts_filt))

#--------------------------------
## COMBAT-SEQ NORMALIZATION AND BATCH CORRECTION WITH LIMMA ##

# count matrix
genus_counts_filt[1:5, 1:5]

# batch vector
batch_vec <- clindat_genus_counts$batch %>%
  as.factor()
names(batch_vec) <- rownames(clindat_genus_counts)
batch_vec[1:5]
enframe(batch_vec) %>% 
  group_by(value) %>%
  summarize(n = n()) %>%
  arrange(n)

# combatseq cannot process groups with n of 1. 
# this only affects 3 individual samples
# will remove groups with one member
keeplist <- enframe(batch_vec) %>% 
  group_by(value) %>%
  summarize(n = n()) %>%
  arrange(n) %>%
  filter(n > 1) %>%
  pull(value) %>%
  as.character() %>%
  # this group also ends up having one member
  .[! . == "A16W07"] %>%
  print()

# get tcga barcodes for batches to keep
barcodes_to_keep <- subset(clindat_genus_counts, batch %in% keeplist) %>%
  rownames(.)
dim(clindat_genus_counts)
length(barcodes_to_keep)
head(barcodes_to_keep)

# subset counts
genus_counts_filt_trim <- genus_counts_filt %>%
  as.data.frame() %>%
  rownames_to_column(var = "tcga_barcode") %>%
  as_tibble() %>%
  select(tcga_barcode, one_of(barcodes_to_keep)) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode") %>%
  as.matrix()
dim(genus_counts_filt)
dim(genus_counts_filt_trim)
genus_counts_filt_trim[1:5, 1:5]

# get batches
kept_barcodes <- colnames(genus_counts_filt_trim)
clindat_genus_counts_trim <- clindat_genus_counts[kept_barcodes, ]
batch_vec_trim <- clindat_genus_counts_trim$batch %>%
  as.factor()
names(batch_vec_trim) <- rownames(clindat_genus_counts_trim)
batch_vec_trim[1:5]
enframe(batch_vec_trim) %>% 
  group_by(value) %>%
  summarize(n = n()) %>%
  arrange(n)

# tumor type (group) marker
tumor_vec <- clindat_genus_counts_trim$tcga_proj
names(tumor_vec) <- rownames(clindat_genus_counts_trim)
tumor_vec[1:5]

genus_counts_adjusted <- ComBat_seq(
  genus_counts_filt_trim, 
  batch = batch_vec_trim,
  group = NULL)

# examine results 
#--------------------------------
## VOOM NORMALIZATION AND BATCH CORRECTION WITH LIMMA ##

# create DGEList
dge <- DGEList(counts = genus_counts_filt)

# apply TMM normalization to DGE
dge <- calcNormFactors(dge)

# set up design matrix
# design matrix should include real differences to be preserved
# Rob Knight paper used tumor type as real difference
# I will do the same
rnames <- rownames(clindat_genus_counts_filt)
TCGA_ <- clindat_genus_counts_filt$tcga_proj %>% as.factor()
summary(TCGA_)
design <- model.matrix(~ 0 + TCGA_)
rownames(design) <- rnames
head(design)

# include sequencing center / plate as a batch variable to the model
batch <- as.factor(clindat_genus_counts_filt$batch)
summary(batch)

# remove batch effects
v <- voom(dge, design, plot = TRUE)
genus_counts_corrected <- removeBatchEffect(v, batch = batch, design = design)

# convert from log space to count space
genus_counts_corrected <- exp(genus_counts_corrected) - 0.5
# check for negative results
genus_counts_corrected[genus_counts_corrected < 0] %>% length()
# what is lowest value?
genus_counts_corrected %>% min()
# round values close to 0 down to 0
summary(as.numeric(genus_counts_corrected))
summary(cpm_lookup$totreads)
# values that round to less than one count are likely noise
# cutoff of 0.5
# this will affect 9965/1764360 values or 0.5%
length(genus_counts_corrected)
length(genus_counts_corrected[genus_counts_corrected < 0.5])
genus_counts_corrected[genus_counts_corrected < 0.5] <- 0
# check for missing results
summary(as.factor(is.finite(genus_counts_corrected)))

# save results as ExpressionSet----------------------------------
# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_counts_filt),
  row.names = colnames(clindat_genus_counts_filt))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_counts_filt, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format
genus_counts_mat <- genus_counts_corrected %>% as.matrix()

# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Missing counts converted to zeros. TMM normalization factors used for voom normalization with tumor type set as experimental design. Batch corrected using limma::removeBatchEffect using tumor type as experimental design and combination of sequencing center and plate (extracted from TCGA barcode) as batch effect. Count values below 0.5 converted to 0, which affects 537 reads.")

# assemble expressionset
genus_counts_es <- ExpressionSet(
  assayData = genus_counts_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_counts_es

# save
saveRDS(genus_counts_es, "output/corrected_genus_counts_expressionset.rds")

# save uncorrected values as ExpressionSet---------------------

# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_counts_filt),
  row.names = colnames(clindat_genus_counts_filt))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_counts_filt, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format
genus_unc_counts_mat <- v$E %>%
  exp() - 0.5

# check for negative results
genus_unc_counts_mat[genus_unc_counts_mat < 0] %>% length()
# what is lowest value?
genus_unc_counts_mat %>% min()

# round values close to 0 down to 0
summary(as.numeric(genus_unc_counts_mat))
summary(cpm_lookup$totreads)
# values that round to less than one count are likely noise
# cutoff of 0.5
# this will affect 9965/1764360 values or 0.5%
length(genus_unc_counts_mat)
length(genus_unc_counts_mat[genus_unc_counts_mat < 0.5])
genus_unc_counts_mat[genus_unc_counts_mat < 0.5] <- 0
# check for missing results
summary(as.factor(is.finite(genus_unc_counts_mat)))

genus_unc_cpm_mat[1:5, 1:5]


# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Missing counts converted to zeros. TMM normalization factors used for voom normalization with tumor type set as experimental design. Count values below 0.5 converted to 0, which affects 714 reads")

# assemble expressionset
genus_counts_unc_es <- ExpressionSet(
  assayData = genus_unc_counts_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_counts_unc_es

# save
saveRDS(genus_counts_unc_es, "output/uncorrected_genus_counts_expressionset.rds")

```

#### Genus microbial only CPM
```{r}
# should pass non-log counts to voom
# voom includes a log2 transformation
# convert missing counts to 0
dim(genus_counts)
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
genus_counts[is.na(genus_counts)] <- 0
summary(as.factor(is.na(genus_counts)))

# check other non-numeric values
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))

# remove cases with any infinite values
genus_counts[!is.finite(genus_counts)] <- NA
genus_counts <- genus_counts[, colSums(is.na(genus_counts)) == 0]

# check again
summary(as.factor(is.na(genus_counts)))
summary(as.factor(is.nan(genus_counts)))
summary(as.factor(is.finite(genus_counts)))
dim(genus_counts)

# remove cases with library size 0
dim(genus_counts)
genus_counts_filt <- genus_counts[, colSums(genus_counts != 0) > 0]
dim(genus_counts_filt)

# convert to CPM (using microbial counts only)
genus_microcpm <- cpm(genus_counts_filt)
genus_counts_filt[1:5, 1:5]
genus_microcpm[1:5, 1:5]

# repair clinical data to match genus counts after cases were dropped
clindat_genus_tbl <- clindat %>%
  rownames_to_column(var = "tcga_barcode") %>%
  as_tibble()

clindat_genus_microcpm <- enframe(colnames(genus_microcpm)) %>%
  dplyr::select(tcga_barcode = value) %>%
  left_join(clindat_genus_tbl) %>%
  as.data.frame() %>%
  column_to_rownames(var = "tcga_barcode")

dim(clindat_genus_microcpm)
clindat_genus_microcpm[1:5, 1:5]

# ensure that rows and columns are matched
identical(colnames(genus_microcpm), rownames(clindat_genus_microcpm))
length(rownames(clindat_genus_microcpm))
length(colnames(genus_microcpm))

# create DGEList
dge <- DGEList(counts = genus_microcpm)

# apply TMM normalization to DGE
dge <- calcNormFactors(dge)

# set up design matrix
# design matrix should include real differences to be preserved
# Rob Knight paper used tumor type as real difference
# I will do the same
rnames <- rownames(clindat_genus_microcpm)
TCGA_ <- clindat_genus_microcpm$tcga_proj %>% as.factor()
summary(TCGA_)
design <- model.matrix(~ 0 + TCGA_)
rownames(design) <- rnames
head(design)

# include sequencing center / plate as a batch variable to the model
batch <- as.factor(clindat_genus_microcpm$batch)
summary(batch)

# remove batch effects
v <- voom(dge, design, plot = TRUE)
genus_microcpm_corrected <- removeBatchEffect(v, batch = batch, design = design)

# convert back to count space
genus_microcpm_corrected <- exp(genus_microcpm_corrected) - 0.5

# check for negative results
genus_microcpm_corrected[genus_microcpm_corrected < 0] %>% 
  length()
# what is lowest value?
genus_microcpm_corrected %>% min()
# what is microbial library size?
summary(colSums(genus_counts))
# median is around 53482, so values of 18.7 correspond to one original count when converted to CPM
# values that round to less than one count are likely noise
# a quick review of data suggests that cutoff of 19 preserves much of the original "0" structure
# this will affect 1494370/1764360 values or 85%
# in the original dataset, 1249240/1764360 were 0, or 71%
length(genus_microcpm_corrected)
length(genus_microcpm_corrected[genus_microcpm_corrected < 19])
genus_microcpm_corrected[genus_microcpm_corrected < 19] <- 0
# check for missing results
summary(as.factor(is.finite(genus_microcpm_corrected)))

genus_microcpm_corrected[1:5, 1:5]

# save results as ExpressionSet
# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_microcpm),
  row.names = colnames(clindat_genus_microcpm))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_microcpm, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format
genus_microcpm_mat <- genus_microcpm_corrected %>% as.matrix()

# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Missing counts converted to zeros. Counts converted to cpm (microbial counts only used for library size). TMM normalization factors used for voom normalization with tumor type set as experimental design. Batch corrected using limma::removeBatchEffect using tumor type as experimental design and combination of sequencing center and plate (extracted from TCGA barcode) as batch effect. Count values below 19 converted to 0.")

# assemble expressionset
genus_microcpm_es <- ExpressionSet(
  assayData = genus_microcpm_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_microcpm_es

# save
saveRDS(genus_microcpm_es, "output/corrected_genus_microcpm_expressionset.rds")

# save uncorrected values as ExpressionSet---------------------

# first need variable annotation
v_metadata <- data.frame(
  labelDescription = colnames(clindat_genus_microcpm),
  row.names = colnames(clindat_genus_microcpm))

# make annotated phenoData
phenoData <- new("AnnotatedDataFrame", 
                 data = clindat_genus_microcpm, 
                 varMetadata = v_metadata)
phenoData

# convert expression data to matrix format (voom normalized, not batch corrected)
genus_microcpm_mat <- v$E %>%
  exp() %>%
  - 0.5

# check for negative results
genus_microcpm_mat[genus_microcpm_mat < 0] %>% 
  length()
# what is lowest value?
genus_microcpm_mat %>% min()
# what is microbial library size?
summary(colSums(genus_counts))
# median is around 53482, so values of 18.7 correspond to one original count when converted to CPM
# values that round to less than one count are likely noise
# a quick review of data suggests that cutoff of 19 preserves much of the original "0" structure
# this will affect 1494370/1764360 values or 85%
# in the original dataset, 1249240/1764360 were 0, or 71%
length(genus_microcpm_mat)
genus_microcpm_mat[1:5, 1:5]
length(genus_microcpm_mat[genus_microcpm_mat < 19])
genus_microcpm_mat[genus_microcpm_mat < 19] <- 0
genus_microcpm_mat[1:5, 1:5]
# check for missing results
summary(as.factor(is.finite(genus_microcpm_mat)))

genus_microcpm_mat[1:5, 1:5]

# create global annotation
annotation <- as.character("Raw counts from Agamemnon mode 2 summarized at genus level (or if genus is not available, at the lowest available taxonomic group at genus or above). Cases with no counts removed. Missing counts converted to zeros. Counts converted to cpm (microbial counts only used for library size). TMM normalization factors used for voom normalization with tumor type set as experimental design. Count values below 19 converted to 0")

# assemble expressionset
genus_microcpm_uncorrected_es <- ExpressionSet(
  assayData = genus_microcpm_mat,
  phenoData = phenoData,
  annotation = annotation)
genus_microcpm_uncorrected_es

# save
saveRDS(genus_microcpm_uncorrected_es, "output/unc_genus_microcpm_expressionset.rds")

```

#### Comprehensive list objects
```{r}
# gather the various data types together in a list for downstream analysis
genus_counts_alldata <- list(
  "corrected_counts" = list(
    "genus_corrected_counts" = genus_counts_corrected_noneg,
    "clindat_counts" = clindat_genus_counts_filt),
  "corrected_cpm" = list(
    "genus_corrected_cpm" = genus_cpm_corrected_noneg,
    "clindat_cpm" = clindat_genus_cpm_filt),
  "corrected_microcpm" = list(
    "genus_corrected_microcpm" = genus_cpm_corrected_noneg,
    "clindat_microcpm" = clindat_genus_microcpm)
)
str(genus_counts_alldata, max.level = 1)
str(genus_counts_alldata, max.level = 2)

saveRDS(genus_counts_alldata, "output/genus_counts_alldata.rds")

genus_counts_es_list <- list(
  "corrected_cpm" = genus_cpm_es,
  "uncorrected_cpm" = genus_cpm_unc_es,
  "corrected_counts" = genus_counts_es,
  "uncorrected_counts" = genus_counts_unc_es,
  "corrected_microcpm" = genus_microcpm_es,
  "uncorrected_microcpm" = genus_microcpm_uncorrected_es
  )

saveRDS(genus_counts_es_list, "output/genus_combined_expressionsets.rds")
```

## Species Limma batch correction
```{r}

```


## Plots
```{r}
# ensure that data approximates normal distribution for limma
# make tidy dataframe for plotting
tidy_generator <- function(listelement){
  listelement %>% 
    pivot_longer(-tcga_barcode, names_to = "genus", values_to = "counts") %>%
    arrange(desc(counts))
}
# make tidy frames with cpm
tidy_genera <- map(cpm_list$genus_cpm, tidy_generator)

# counts distribution
counts_dist_plotter <- function(df){
  plot <- df %>%
    ggplot(aes(x = counts, color = tcga_barcode)) +
      geom_density() +
      theme(legend.position = "none")
}

# plot raw distributions of cpm for each tumor type
dist_plot_list <- map(tidy_genera, counts_dist_plotter)
do.call(ggarrange, dist_plot_list) %>%
  annotate_figure(., top = text_grob("Counts Distribution by Genus", color = "black", face = "bold", size = 14))
          
# log cpm distribution
log_dist_plotter <- function(df){
  plot <- df %>%
    mutate(lcounts = log2(counts)) %>%
    dplyr::filter(lcounts > -100) %>%
    ggplot(aes(x = lcounts), color = tcga_barcode) +
      geom_density() +
      theme(legend.position = "none") +
      expand_limits(x = c(-20, 30))
}
# log cpm density plots
log_plot_list <- map(tidy_genera, log_dist_plotter)
names(log_plot_list) <- names(tidy_genera)
do.call(ggarrange, log_plot_list) %>%
  annotate_figure(., top = text_grob("log(Counts) Distribution by Genus", color = "black", face = "bold", size = 14))

# log counts have a more normal distribution. unlogged counts have right skew
```
